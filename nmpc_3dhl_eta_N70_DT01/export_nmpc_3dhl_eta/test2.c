/*
 *    This file was auto-generated by ACADO Code Generation Tool.
 *    
 *    ACADO Code Generation tool is a sub-package of ACADO toolkit --
 *    A Toolkit for Automatic Control and Dynamic Optimization.
 *    Copyright (C) 2008-2014 by Boris Houska, Hans Joachim Ferreau,
 *    Milan Vukov, Rien Quirynen, KU Leuven.
 *    Developed within the Optimization in Engineering Center (OPTEC)
 *    under supervision of Moritz Diehl. All rights reserved.
 *    
 *    ACADO Toolkit is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 3 of the License, or (at your option) any later version.
 *    
 *    ACADO Toolkit is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *    
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with ACADO Toolkit; if not, write to the Free Software
 *    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *    
 */


/*

IMPORTANT: This file should serve as a starting point to develop the user
code for the OCP solver. The code below is for illustration purposes. Most
likely you will not get good results if you execute this code without any
modification(s).

Please read the examples in order to understand how to write user code how
to run the OCP solver. You can find more info on the website:
www.acadotoolkit.org 

*/

#include "acado_common.h"
#include "acado_auxiliary_functions.h"

#include <stdio.h>

/* Some convenient definitions. */
#define NX          ACADO_NX  /* Number of differential state variables.  */
#define NXA         ACADO_NXA /* Number of algebraic variables. */
#define NU          ACADO_NU  /* Number of control inputs. */
#define NOD         ACADO_NOD  /* Number of online data values. */

#define NY          ACADO_NY  /* Number of measurements/references on nodes 0..N - 1. */
#define NYN         ACADO_NYN /* Number of measurements/references on node N. */

#define N           ACADO_N   /* Number of intervals in the horizon. */

#define NUM_STEPS   10        /* Number of real-time iterations. */
#define VERBOSE     1         /* Show iterations: 1, silent: 0.  */

/* Global variables used by the solver. */
ACADOvariables acadoVariables;
ACADOworkspace acadoWorkspace;

/* A template for testing of the solver. */
int main()
{
	/* Some temporary variables. */
	int    i, iter, j;
	timer t;
	
	/* Initialize the solver. */
	initializeSolver();
	
	/* Initialize the states and controls. */
    double xx[13] = {302.166281881227,-57.9165964508796,1.34837746810244e-05,13.4986651799426,-1.19262032962240e-14,-1.85342061304962e-09,2.14751740412947e-09,0.0129472350298353,-1.81571000360607e-09,3.15006262166046e-14,1.62974382887163e-09,0.366953922894259,0};
	for (i = 0; i < (N + 1); ++i)
        for (j = 0; j < NX; ++j) acadoVariables.x[ NX * i + j ] = xx[ j ];
    
    double uu[3] = {0.366953922894368,1.00893823530043e-09,0.0213880802709292};
	for (i = 0; i < N; ++i)
        for (j = 0; j < NU; ++j) acadoVariables.u[ NU * i + j ] = uu[ j ];
	
	/* Initialize the measurements/reference. */
	double yy[11] = {0,0,13.5000000000000,0,0,0,0,0,0.375000000000000,0,0.0296705972839036};
	for (i = 0; i < N; ++i)
        for (j = 0; j < NY; ++j) acadoVariables.y[ NY * i + j ] = yy[ j ];
    
	for (i = 0; i < NYN; ++i)  acadoVariables.yN[ i ] = yy[ i ];
    
    /* online data */
    double odod[24] = {0,0,500,0,0,1.57079632679490,0,0,0,500,0,0,1.57079632679490,0,30,0.800000000000000,0,0,0,0.139626340159546,-0.0523598775598299,0.0349065850398866,5,0.500000000000000};
	for (i = 0; i < (N+1); ++i)
        for (j = 0; j < NOD; ++j) acadoVariables.od[ NOD * i + j ] = odod[ j ];

	/* MPC: initialize the current state feedback. */
	for (i = 0; i < NX; ++i) acadoVariables.x0[ i ] = xx[ i ];
    
    double inin[NX+NU+NOD];
    for (i = 0; i < NX; ++i) inin[ i ] = xx[ i ];
    for (i = 0; i < NU; ++i) inin[ i+NX ] = uu[ i ];
    for (i = 0; i < NOD; ++i) inin[ i+NX+NU ] = odod[ i ];
    
    double outout[NY];
            
    lsq_objN_eval( inin, outout );
    
    printf("out=[%f,%f,%f,%f,%f,%f,%f,%f,%f,%f,%f]\n",outout[0],outout[1],outout[2],outout[3],outout[4],outout[5],outout[6],outout[7],outout[8],outout[9],outout[10]);
      
	if( VERBOSE ) printHeader();
	
	/* Prepare first step */
	preparationStep();
	
	/* Get the time before start of the loop. */
// 	tic( &t );

	/* The "real-time iterations" loop. */
	for(iter = 0; iter < NUM_STEPS; ++iter)
	{
        /* Perform the feedback step. */
		feedbackStep( );

		/* Apply the new control immediately to the process, first NU components. */
		
		if( VERBOSE ) printf("\tReal-Time Iteration %d:  KKT Tolerance = %.3e\n\n", iter, getKKT() );

		/* Optional: shift the initialization (look at acado_common.h). */
        /* shiftStates(2, 0, 0); */
		/* shiftControls( 0 ); */

		/* Prepare for the next step. */
		preparationStep();
	}
	/* Read the elapsed time. */
// 	real_t te = toc( &t );
	
// 	if( VERBOSE ) printf("\n\nEnd of the RTI loop. \n\n\n");

	/* Eye-candy. */
	
// 	if( !VERBOSE )
// 	printf("\n\n Average time of one real-time iteration:   %.3g microseconds\n\n", 1e6 * te / NUM_STEPS);

	printDifferentialVariables();
	printControlVariables();

    return 0;
}